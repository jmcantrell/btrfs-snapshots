#!/usr/bin/env bash

# Show that prune will preserve the correct snapshots.

set -eu

. "$LIB_DIR"/init.sh
. "$TESTS_LIB_DIR"/init.sh

export SUBVOLUME=$TEMP_DIR/subvolume
export SNAPSHOTS=$TEMP_DIR/snapshots
export PROFILE_NAME=foo

limit=3

for event_name in "${EVENT_NAMES[@]}"; do
    reset_temp

    set_limit "$event_name" "$limit"

    keepers=()
    fillers=()
    stdout_lines=()

    while IFS= read -r -d $'\n' event_start; do
        # This snapshot is the earliest one of this event, so it should not be
        # deleted.
        keeper=$SNAPSHOTS/$event_start
        keepers+=("$keeper")

        # Generate a bunch of filler snapshots within the same event that will
        # eventually be deleted.
        while IFS= read -r -d $'\n' event_step; do
            snapshot=$SNAPSHOTS/$event_step
            mkdir -p "$snapshot"

            # Only predict the message if it's not the keeper.
            if [[ $snapshot != "$keeper" ]]; then
                fillers+=("$snapshot")
                stdout_lines+=("$(format "$TEXT_BTRFS_DELETE" SNAPSHOT="$snapshot")")
            fi
        done < <(timestamp_sequence "$event_start" "1 second" "$limit" | tac)
    done < <(timestamp_sequence_event "$TIMESTAMP" "$event_name" "$limit" | tac)

    printf -v stdout "%s\n" "${stdout_lines[@]}"

    assert_success assert_stdout "$stdout" \
        prune

    assert_equal "$(list | wc -l)" "$limit"

    for keeper in "${keepers[@]}"; do
        assert_directory "$keeper"
    done

    for filler in "${fillers[@]}"; do
        assert_no_directory "$filler"
    done
done
